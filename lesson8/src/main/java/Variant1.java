public class Variant1 {
    /* static void task1() {

        Создать новый класс для потока через наследование от класса Thread.
        Переопределить метод run.
        В переопределённом методе run выводить в консоль имя текущего потока и его id.
        В переопределённом методе run должен быть слип на пол секунды.
        Создать динамический массив потоков и запустить их в цикле в обратном порядке (по убыванию)
        При этом потоки должны запускаться не хаотично, а строго по порядку. С начала самый последний, потом предпоследний и т.д



    public static void main(String[] args) {
        task1();
        new Task().task2();
        new Task().task3();
    }*/

   /* void task2() {

        Программа создаёт 5 потоков через класс EmployeeThread.
        У класса EmployeeThread есть приватная статическая переменная с названием thread.
        Переменная thread используется в переопределённом методе run, там же в эту переменную устанавливается текущий поток.
        В конце метода run в консоль выводиться сообщения с текущим id потока, его именем и id потока,
         который содержится в переменной thread.

        Сейчас программа работает с ошибкой и первый поток может установить переменную thread,
         а другие потоки могут использовать значение, которое было установлено первым потоком.
        Если вы запустите программу, то станет ясно, что id текущего потока не равно id потока,
         который установлен в переменной thread.

        Вам надо модифицировать код класс EmployeeThread так, что бы у каждого потока была своя отдельная переменная thread.
        Запрещено убирать ключевое слово static у переменной thread.
        В результате у вас должна быть логика, которая не позволит потоку использовать значение переменной thread,
         которое было установленно другим потоком ранее.

        Задача рассчитана на понимание потокобезопасности.

        Для решения задачи запрещено использовать оператор synchronized, класс ReentrantLock и методы join(), wait, notify, notifyAll

        for (int i = 0; i < 5; i++) {
            new EmployeeThread("Thread with index " + i).start();
        }
    }*/

    void task3() {
        /*
        У нас есть микросервисное приложение, в котором есть класс MessageService, отвечающий за операции с сообщениями
        на сервере.
        Так же есть класс MessageClientService, который обрабатывает данные от сервера и показывает их конечному
        пользователю в понятном виде.
        Вам необходимо разработать программу, которая позволяет запускать эти сервисы в разных потоках.
        Поток для сервиса MessageService должен иметь возможность получать данные из потока для работы с клиентом.
        Поток для сервиса MessageClientService должен получать данные от потока для работы с базой данных.

        В результате у вас должно получиться улучшенное микросервисное приложение, которое может запускать сервисы в
        разных потоках и каждый из сервисов может перехватывать сообщения друг друга.
        Так же у вас должна быть логика обработки сообщения в каждом сервисе.
        Сервис MessageService должен переворачивать отправляемые сообщения задом на перёд, выводить в консоль и только
        потом отправлять в MessageClientService
        Сервис MessageClientService должен обратно приводить сообщения от сервиса MessageClientService в читаемый
        вид и выводить в косноль.
         */
    }

}
